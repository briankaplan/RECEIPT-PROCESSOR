#!/usr/bin/env python3
â€œâ€â€
Token Files Generator for Gmail Intelligence System
This script will help you generate and refresh all required token files
â€œâ€â€

import os
import pickle
import json
from pathlib import Path
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build

# Gmail API scopes

SCOPES = [
â€˜https://www.googleapis.com/auth/gmail.readonlyâ€™,
â€˜https://www.googleapis.com/auth/gmail.modifyâ€™,
â€˜https://www.googleapis.com/auth/gmail.sendâ€™
]

class TokenGenerator:
def **init**(self):
self.accounts = {
â€˜kaplan.brian@gmail.comâ€™: {
â€˜emailâ€™: â€˜kaplan.brian@gmail.comâ€™,
â€˜pickle_fileâ€™: â€˜gmail_tokens/kaplan.brian_at_gmail.com.pickleâ€™,
â€˜client_fileâ€™: â€˜gmail_tokens/kaplan.brian_at_gmail.com_token.jsonâ€™,
â€˜portâ€™: 8080
},
â€˜brian@downhome.comâ€™: {
â€˜emailâ€™: â€˜brian@downhome.comâ€™,
â€˜pickle_fileâ€™: â€˜gmail_tokens/brian_at_downhome.com.pickleâ€™,
â€˜client_fileâ€™: â€˜gmail_tokens/brian_at_downhome.com_token.jsonâ€™,
â€˜portâ€™: 8082
},
â€˜brian@musiccityrodeo.comâ€™: {
â€˜emailâ€™: â€˜brian@musiccityrodeo.comâ€™,
â€˜pickle_fileâ€™: â€˜gmail_tokens/brian_at_musiccityrodeo.com.pickleâ€™,
â€˜client_fileâ€™: â€˜gmail_tokens/brian_at_musiccityrodeo.com_token.jsonâ€™,
â€˜portâ€™: 8081
}
}

```
    # Create tokens directory if it doesn't exist
    Path('gmail_tokens').mkdir(exist_ok=True)

def create_credentials_template(self):
    """Create a template credentials.json file"""
    template = {
        "installed": {
            "client_id": "YOUR_CLIENT_ID.apps.googleusercontent.com",
            "project_id": "YOUR_PROJECT_ID",
            "auth_uri": "https://accounts.google.com/o/oauth2/auth",
            "token_uri": "https://oauth2.googleapis.com/token",
            "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
            "client_secret": "YOUR_CLIENT_SECRET",
            "redirect_uris": ["urn:ietf:wg:oauth:2.0:oob", "http://localhost"]
        }
    }
    
    with open('gmail_tokens/credentials_template.json', 'w') as f:
        json.dump(template, f, indent=2)
    
    print("âœ… Created credentials_template.json")
    print("ğŸ“ Please update with your actual Google Cloud Console credentials")

def generate_token_for_account(self, email, credentials_file='gmail_tokens/credentials.json'):
    """Generate OAuth token for a specific account"""
    if not os.path.exists(credentials_file):
        print(f"âŒ Credentials file not found: {credentials_file}")
        print("ğŸ“ Please create credentials.json from Google Cloud Console")
        return False
    
    account = self.accounts[email]
    pickle_file = account['pickle_file']
    port = account['port']
    
    creds = None
    
    # Load existing token if available
    if os.path.exists(pickle_file):
        with open(pickle_file, 'rb') as token:
            creds = pickle.load(token)
            print(f"ğŸ“ Loaded existing token for {email}")
    
    # Refresh or create new token
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            print(f"ğŸ”„ Refreshing token for {email}")
            creds.refresh(Request())
        else:
            print(f"ğŸŒ Creating new token for {email}")
            print(f"ğŸš€ Browser will open on port {port}")
            flow = InstalledAppFlow.from_client_secrets_file(
                credentials_file, SCOPES)
            creds = flow.run_local_server(port=port)
        
        # Save the token
        with open(pickle_file, 'wb') as token:
            pickle.dump(creds, token)
        print(f"ğŸ’¾ Saved token for {email}")
    
    # Test the token
    try:
        service = build('gmail', 'v1', credentials=creds)
        profile = service.users().getProfile(userId='me').execute()
        print(f"âœ… Token verified for {email} - {profile['emailAddress']}")
        return True
    except Exception as e:
        print(f"âŒ Token verification failed for {email}: {e}")
        return False

def generate_all_tokens(self):
    """Generate tokens for all accounts"""
    print("ğŸš€ Starting token generation for all accounts...")
    
    credentials_file = 'gmail_tokens/credentials.json'
    if not os.path.exists(credentials_file):
        print(f"âŒ Main credentials file not found: {credentials_file}")
        self.create_credentials_template()
        return
    
    for email in self.accounts.keys():
        print(f"\nğŸ“§ Processing {email}...")
        success = self.generate_token_for_account(email, credentials_file)
        if not success:
            print(f"âŒ Failed to generate token for {email}")

def refresh_token(self, email):
    """Refresh token for specific account"""
    if email not in self.accounts:
        print(f"âŒ Unknown email: {email}")
        return False
    
    account = self.accounts[email]
    pickle_file = account['pickle_file']
    
    if not os.path.exists(pickle_file):
        print(f"âŒ Token file not found: {pickle_file}")
        return False
    
    try:
        with open(pickle_file, 'rb') as token:
            creds = pickle.load(token)
        
        if creds.expired and creds.refresh_token:
            print(f"ğŸ”„ Refreshing token for {email}")
            creds.refresh(Request())
            
            with open(pickle_file, 'wb') as token:
                pickle.dump(creds, token)
            print(f"âœ… Token refreshed for {email}")
            return True
        else:
            print(f"âœ… Token for {email} is still valid")
            return True
            
    except Exception as e:
        print(f"âŒ Failed to refresh token for {email}: {e}")
        return False

def check_all_tokens(self):
    """Check status of all tokens"""
    print("ğŸ” Checking status of all tokens...\n")
    
    for email, account in self.accounts.items():
        pickle_file = account['pickle_file']
        
        if os.path.exists(pickle_file):
            try:
                with open(pickle_file, 'rb') as token:
                    creds = pickle.load(token)
                
                if creds.valid:
                    print(f"âœ… {email}: Valid token")
                elif creds.expired:
                    if creds.refresh_token:
                        print(f"ğŸ”„ {email}: Expired but can refresh")
                    else:
                        print(f"âŒ {email}: Expired, needs re-authentication")
                else:
                    print(f"â“ {email}: Invalid token")
                    
            except Exception as e:
                print(f"âŒ {email}: Error reading token - {e}")
        else:
            print(f"âŒ {email}: No token file found")
```

def main():
generator = TokenGenerator()

```
print("Gmail Token Generator")
print("===================")
print()
print("1. Check all tokens")
print("2. Generate template credentials file")
print("3. Generate tokens for all accounts")
print("4. Generate token for specific account")
print("5. Refresh token for specific account")
print()

choice = input("Choose an option (1-5): ").strip()

if choice == '1':
    generator.check_all_tokens()

elif choice == '2':
    generator.create_credentials_template()

elif choice == '3':
    generator.generate_all_tokens()

elif choice == '4':
    print("\nAvailable accounts:")
    for i, email in enumerate(generator.accounts.keys(), 1):
        print(f"{i}. {email}")
    
    try:
        account_choice = int(input("\nChoose account number: ")) - 1
        email = list(generator.accounts.keys())[account_choice]
        generator.generate_token_for_account(email)
    except (ValueError, IndexError):
        print("âŒ Invalid choice")

elif choice == '5':
    print("\nAvailable accounts:")
    for i, email in enumerate(generator.accounts.keys(), 1):
        print(f"{i}. {email}")
    
    try:
        account_choice = int(input("\nChoose account number: ")) - 1
        email = list(generator.accounts.keys())[account_choice]
        generator.refresh_token(email)
    except (ValueError, IndexError):
        print("âŒ Invalid choice")

else:
    print("âŒ Invalid choice")
```

if **name** == â€œ**main**â€:
main()